summary(GA)
res <- persp(x, y, z, theta = 45, phi = 20, expand = 1, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed")
max_x = GA@solution[,1]
max_y = GA@solution[,2]
max_z = f(GA@solution[,1], GA@solution[,2])
points(trans3d(max_x, max_y, max_z, pmat=res), col="red")
lines (trans3d(x, max_y, max_z, pmat = res), col = "blue")
lines (trans3d(max_x, y, max_z, pmat = res), col = "blue")
## Task 1: Maximization of a non-convex function.
# 1. Code a method f(x, y) that computes a value z, given an input tuple (x, y).
f <- function(x, y)  {
z <- ((1 - x)^2) + (exp(1) * (y - (x^2))^2)
}
# 2. Code a method that visualizes the Rosenbrock function in 3D
x <- y <- seq(-1, 1, length= 400)
z <- outer(x, y, f)
z[is.na(z)] <- 1 # change non-defined elements to 1
persp(x, y, z, theta = 0, phi = 25, expand = 1, col = "lightblue", ticktype = "detailed")
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = 1000, run = 100)
plot(GA)
summary(GA)
res <- persp(x, y, z, theta = 45, phi = 20, expand = 1, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed")
max_x = GA@solution[,1]
max_y = GA@solution[,2]
max_z = f(GA@solution[,1], GA@solution[,2])
points(trans3d(max_x, max_y, max_z, pmat=res), col="red")
lines (trans3d(x, max_y, max_z, pmat = res), col = "blue")
lines (trans3d(max_x, y, max_z, pmat = res), col = "blue")
plot(Age, Vol)
lines(Age, model(GA2@solution))
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = 1000, run = 100)
GA$solution
GA@solution
GA2@solution
myMonitor2 <- function(obj)
{
i <- which.max(obj@fitness)
plot(Age, Vol)
lines(Age, model(obj@population[i,]), col="red")
title(paste("iteration =", obj@iter), font.main = 1)
Sys.sleep(1)
}
GA2 <- ga(type = "real-valued", fitness = myFitness2, lower = c(1000, 0, 0), upper = c(5000, 5, 5),
popSize = 500, crossover = gareal_blxCrossover, maxiter = 5000, run = 200, names = c("a", "b", "c"), monitor=myMonitor2)
contour(x1, x2, f, drawlabels = FALSE, col = grey(0.5))
contour(x, y, z, drawlabels = FALSE, col = grey(0.5))
# BONUS: Plot the trace of evolution
monitor <- function(obj)
{
contour(x, y, z, drawlabels = FALSE, col = grey(0.5))
title(paste("iteration =", obj@iter), font.main = 1)
points(obj@population, obj@fitness, pch = 20, col = 2)
Sys.sleep(0.2)
}
res
s = seq(-1, 0.1, 1)
lines (trans3d(x, max_y, s, pmat = res), col = "green")
## Task 1: Maximization of a non-convex function.
# 1. Code a method f(x, y) that computes a value z, given an input tuple (x, y).
f <- function(x, y)  {
z <- ((1 - x)^2) + (exp(1) * (y - (x^2))^2)
}
# 2. Code a method that visualizes the Rosenbrock function in 3D
x <- y <- seq(-1, 1, length= 400)
z <- outer(x, y, f)
z[is.na(z)] <- 1 # change non-defined elements to 1
persp(x, y, z, theta = 0, phi = 25, expand = 1, col = "lightblue", ticktype = "detailed")
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = 1000, run = 100)
plot(GA)
summary(GA)
res <- persp(x, y, z, theta = 45, phi = 20, expand = 1, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed")
max_x = GA@solution[,1]
max_y = GA@solution[,2]
max_z = f(GA@solution[,1], GA@solution[,2])
points(trans3d(max_x, max_y, max_z, pmat=res), col="red")
lines (trans3d(x, max_y, max_z, pmat = res), col = "blue")
lines (trans3d(max_x, y, max_z, pmat = res), col = "blue")
# BONUS: Plot the trace of evolution
monitor <- function(obj)
{
contour(x, y, z, drawlabels = FALSE, col = grey(0.5))
title(paste("iteration =", obj@iter), font.main = 1)
points(obj@population, obj@fitness, pch = 20, col = 2)
Sys.sleep(0.2)
}
res
s = seq(-1, 0.1, 1)
lines (trans3d(x, max_y, s, pmat = res), col = "green")
ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = 1000, run = 100,
monitor = monitor)
s = seq(-1, 0.1, 1)
lines (trans3d(x, max_y, s, pmat = res), col = "green")
# BONUS: Plot the trace of evolution
monitor <- function(obj)
{
contour(x, y, z, drawlabels = FALSE, col = grey(0.5))
title(paste("iteration =", obj@iter), font.main = 1)
points(obj@population, obj@fitness, pch = 20, col = 2)
Sys.sleep(0.2)
}
ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = 1000, run = 100,
monitor = monitor)
# BONUS: Plot the trace of evolution
monitor <- function(obj)
{
contour(x, y, z)
title(paste("iteration =", obj@iter), font.main = 1)
points(obj@population, obj@fitness, pch = 20, col = 2)
Sys.sleep(0.2)
}
ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = 1000, run = 100,
monitor = monitor)
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = 1000, run = 100)
plot(GA)
summary(GA)
res <- persp(x, y, z, theta = 45, phi = 20, expand = 1, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed")
max_x = GA@solution[,1]
max_y = GA@solution[,2]
max_z = f(GA@solution[,1], GA@solution[,2])
points(trans3d(max_x, max_y, max_z, pmat=res), col="red")
lines (trans3d(x, max_y, max_z, pmat = res), col = "blue")
lines (trans3d(max_x, y, max_z, pmat = res), col = "blue")
GA
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = 1000, run = 100)
GA
GA@iter
GA@run
GA@optim
GA@bestSol
GA@fitnessValue
GA@solution
summary(GA)
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
GA@solution
}
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100, echo = OFF)
GA@solution
}
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100, echo = "OFF")
GA@solution
}
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100, echo = 'OFF')
GA@solution
}
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100, echo = FALSE)
GA@solution
}
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
for (i in 1:30) {
{r pressure, echo=FALSE}
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100, echo = FALSE)
GA@solution
}
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
for (i in 1:30) {
{r pressure, echo=FALSE}
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
GA@solution
}
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
history = []
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history[i] <- GA@solution
}
history
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
history = []
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history[i] <- GA@solution[1,]
}
history
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
history = []
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history[i] <- GA@solution[1,]
}
history
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
history = []
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history[i] <- GA@solution[,1]
}
history
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
history = []
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history[i] <- 1
}
history
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
history = []
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history[i] <- 1
}
history
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history[i] <- 1
}
history
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history[i] <- 1
}
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
history = c()
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history[i] <- 1
}
history
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
history = c()
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history[i] <- GA@solution
}
history
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history_x[i] <- GA@solution[,1]
history_y[i] <- GA@solution[,2]
history_z[i] <- f(GA@solution[,1], GA@solution[,2])
# BONUS: Plot the trace of evolution
history_x = c()
history_y = c()
history_z = c()
for (i in 1:30) {
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history_x[i] <- GA@solution[,1]
history_y[i] <- GA@solution[,2]
history_z[i] <- f(GA@solution[,1], GA@solution[,2])
for (i in 1:30) {
GA2 <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history_x[i] <- GA2@solution[,1]
history_y[i] <- GA2@solution[,2]
history_z[i] <- f(GA2@solution[,1], GA2@solution[,2])
for (i in 1:30) {
GA2 <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = i*10, run = 100)
history_x[i] <- GA2@solution[,1]
#history_y[i] <- GA2@solution[,2]
#history_z[i] <- f(GA2@solution[,1], GA2@solution[,2])
# 3. Code a genetic algorithm, that attempts to find the global maximum of this function.
GA <- ga(type = "real-valued",
fitness =  function(x) f(x[1], x[2]),
lower = c(-1, -1), upper = c(1, 1),
popSize = 50, maxiter = 1000, run = 100)
library(caret)
library("rgl")
library("plot3D")
library("GA")
##Task 2: Genetic feature selection
# Work plan:
# 1) Read in the data
# 2) Split the data into training and test sets
# 3) Build a model using the training set
# 4) Evaluate the model using the test set
# 1) Read in the dataset
genes <- read.csv("DLBCL.csv")
summary(genes)
target <- genes$class
genes <- genes[,-which(names(genes) == "class")]
setwd("~/Documents/IS/hw01/IntelligentSystems")
# 1) Read in the dataset
genes <- read.csv("DLBCL.csv")
summary(genes)
target <- genes$class
genes <- genes[,-which(names(genes) == "class")]
# 2) Split the data into training and test sets
splited <- createDataPartition(
y = target,
p = .8,
list = FALSE
)
str(splited)    # The output is a set of integers for the rows of genes that belong in the training set.
learn = genes[ splited, ]
test = genes[-splited, ]
nrow(learn)
nrow(test)
table(learn$class)
table(test$class)
# 3) Build a model using the training set
# (TODO: • Fitness must take into account both the number of features, as well as the classifier’s performance)
ctrl <- trainControl(number = 3,
method = "repeatedcv")
model <- train(
class ~ .,   # TODO: change from 2 to 1000
data = learn,
method = "pls",
preProc = c("center", "scale"),
trControl = ctrl
)
ggplot(model)
# 1) Read in the dataset
genes <- read.csv("DLBCL.csv")
summary(genes)
target <- genes$class
#genes <- genes[,-which(names(genes) == "class")]
# 2) Split the data into training and test sets
splited <- createDataPartition(
y = target,
p = .8,
list = FALSE
)
str(splited)    # The output is a set of integers for the rows of genes that belong in the training set.
learn = genes[ splited, ]
test = genes[-splited, ]
nrow(learn)
nrow(test)
table(learn$class)
table(test$class)
learn$X <- NULL
test$X <- NULL
# 3) Build a model using the training set
# (TODO: • Fitness must take into account both the number of features, as well as the classifier’s performance)
ctrl <- trainControl(number = 3,
method = "repeatedcv")
PLSModel <- train(
class ~ .,   # TODO: change from 2 to 1000
data = learn,
method = "pls",
preProc = c("center", "scale"),
trControl = ctrl,
tuneLenght = 1000
)
RFModel <- train(
class ~ .,
data = learn,
method = "rf",
preProc = c("center", "scale"),
trControl = ctrl,
tuneLenght = 1000
)
xgbModel <- train(
class ~ .,
data = learn,
method = "xgbDART",
preProc = c("center", "scale"),
trControl = ctrl,
tuneLenght = 100
)
RFModel <- train(
class ~ .,
data = learn,
method = "rf",
preProc = c("center", "scale"),
trControl = ctrl,
tuneLenght = 1000
)
xgbModel <- train(
class ~ .,
data = learn,
method = "xgbDART",
preProc = c("center", "scale"),
trControl = ctrl,
tuneLenght = 100
)
SVMModel <- train(
class ~ .,
data = learn,
method = "svmRadial",
preProc = c("center", "scale"),
trControl = ctrl,
tuneLenght = 1000
)
models_compare <- resamples(list(RF=RFModel, XGBDART=xgbModel, PLS=PLSModel, SVM=SVMModel))
summary(models_compare)
varimp <- varImp(RFModel)
imp <- varimp$importance
plot(varimp)
View(varimp)
varimp[["importance"]][["Overall"]]
summary(models_compare)
# 4) Evaluate the model using the test set (TODO: try different models)
plsClasses <- predict(xgbModel, newdata = test)
str(plsClasses)
plsProbs <- predict(xgbModel, newdata = test, type = "prob")
head(plsProbs)
confusionMatrix(data = plsClasses, test$class)
varimp
SVMModel
RFModel <- train(
class ~ [1:1000],
data = learn,
method = "rf",
preProc = c("center", "scale"),
trControl = ctrl,
tuneLenght = 1000
)
PLSModel <- train(
genes[,-1072],   # TODO: change from 2 to 1000
data = genes[,1072],
method = "pls",
preProc = c("center", "scale"),
trControl = ctrl,
tuneLenght = 1000
)
,-1072
